<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Quantum Factory Tycoon ‚Äî Neural Mining Flow</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      font-family: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background: #05070f;
      color: #e9f9ff;
      touch-action: none;
    }
    body {
      position: relative;
      background:
        radial-gradient(circle at 25% 30%, rgba(0,255,255,0.08), transparent 55%),
        radial-gradient(circle at 75% 70%, rgba(140,0,255,0.10), transparent 55%),
        radial-gradient(circle at 40% 80%, rgba(120,0,255,0.06), transparent 55%),
        radial-gradient(circle at 50% 50%, #02030a, #000000 70%);
    }
    canvas {
      position: absolute;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      touch-action: none;
    }

    .hud {
      position: fixed;
      padding: 12px 16px;
      border-radius: 16px;
      background: rgba(0,255,255,0.10);
      border: 1px solid rgba(0,255,255,0.35);
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
      box-shadow: 0 0 18px rgba(0,255,255,0.25);
      font-size: 13px;
      line-height: 1.4;
      z-index: 50;
      pointer-events: auto; /* clics activ√©s pour ouvrir les modals */
      cursor: pointer;
    }
    .hud span.label {
      opacity: .7;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: .08em;
      display: block;
      margin-bottom: 2px;
    }
    .hud span.value {
      font-weight: 600;
      font-size: 14px;
      white-space: nowrap;
    }
    #hud-tl { top: 16px; left: 16px; }
    #hud-tr { top: 16px; right: 16px; text-align: right; }
    #hud-bl { bottom: 16px; left: 16px; }
    #hud-br { bottom: 16px; right: 16px; text-align: right; }

    #hud-prestige-zone { margin-top:4px; font-size:11px; pointer-events:auto; }

    .prestige-btn {
      display:inline-block;
      padding:4px 8px;
      border-radius:10px;
      border:1px solid rgba(255,215,0,0.9);
      background:rgba(60,40,0,0.9);
      color:#fff7c0;
      font-size:11px;
      cursor:pointer;
      transition:background .12s,box-shadow .12s,transform .08s;
    }
    .prestige-btn:hover {
      background:rgba(255,215,0,0.25);
      box-shadow:0 0 14px rgba(255,215,0,0.9);
      transform:translateY(-1px);
    }

    .contextMenu {
      position: fixed;
      min-width: 180px;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(60,20,120,0.9);
      border: 1px solid rgba(210,180,255,0.9);
      backdrop-filter: blur(22px);
      -webkit-backdrop-filter: blur(22px);
      box-shadow: 0 0 26px rgba(160,120,255,0.9);
      color: #fdf8ff;
      font-size: 13px;
      z-index: 200;
      display: none;
    }
    .contextMenu h4 {
      margin-bottom: 6px;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: .09em;
      opacity: .85;
    }
    .contextMenu .info { font-size: 12px; opacity: .9; margin-bottom: 4px; }
    .contextMenu .cost { font-size: 11px; margin-top: 4px; opacity: .85; }
    .contextMenu button {
      width: 100%;
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid rgba(0,255,255,0.8);
      background: rgba(0,0,0,0.35);
      color: #e9ffff;
      font-size: 12px;
      cursor: pointer;
      margin-top: 4px;
      transition: background .12s, box-shadow .12s, transform .08s;
    }
    .contextMenu button:hover {
      background: rgba(0,255,255,0.25);
      box-shadow: 0 0 14px rgba(0,255,255,0.8);
      transform: translateY(-1px);
    }

    #placeMenu {
      position: fixed;
      display: none;
      min-width: 160px;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(60,20,120,0.9);
      border: 1px solid rgba(210,180,255,0.9);
      backdrop-filter: blur(22px);
      -webkit-backdrop-filter: blur(22px);
      box-shadow: 0 0 26px rgba(160,120,255,0.9);
      color: #fdf8ff;
      font-size: 13px;
      z-index: 200;
    }
    #placeMenu button {
      width: 100%;
      margin-top: 4px;
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid rgba(0,255,255,0.8);
      background: rgba(0,0,0,0.35);
      color: #e9ffff;
      font-size: 12px;
      cursor: pointer;
      transition: background .12s, box-shadow .12s, transform .08s;
    }
    #placeMenu button:hover {
      background: rgba(0,255,255,0.25);
      box-shadow: 0 0 14px rgba(0,255,255,0.8);
      transform: translateY(-1px);
    }

    .panel {
      position: fixed;
      right: 16px;
      top: 120px;
      width: 260px;
      padding: 12px 14px;
      border-radius: 16px;
      background: rgba(20,10,40,0.92);
      border: 1px solid rgba(180,140,255,0.7);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      box-shadow: 0 0 22px rgba(140,80,255,0.6);
      font-size: 12px;
      z-index: 120;
      display: none;
    }
    .panel h3 {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: .09em;
      opacity: .85;
      margin-bottom: 6px;
    }
    .panel .tech {
      padding: 6px 6px;
      border-radius: 10px;
      border: 1px solid rgba(0,255,255,0.4);
      margin-bottom: 6px;
      cursor: pointer;
      transition: background .12s, border-color .12s;
    }
    .panel .tech.locked { opacity: .8; }
    .panel .tech.unlocked {
      border-color: rgba(140,255,140,0.9);
      background: rgba(20,80,40,0.6);
      cursor: default;
    }
    .panel .tech:hover:not(.unlocked) {
      background: rgba(0,255,255,0.12);
      border-color: rgba(0,255,255,0.9);
    }
    .panel .tech-title { font-weight: 600; margin-bottom: 2px; }
    .panel .tech-desc { opacity: .85; margin-bottom: 2px; }
    .panel .tech-cost { font-size: 11px; opacity: .8; }

    .rarity-common { color:#cfd8ff; }
    .rarity-rare { color:#7ffcff; }
    .rarity-epic { color:#ff7fff; }
    .rarity-legendary { color:#ffd700; }

    .event-log {
      position: fixed;
      left: 16px;
      bottom: 80px;
      width: 260px;
      padding: 10px 12px;
      border-radius: 16px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(0,255,255,0.25);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      font-size: 11px;
      line-height: 1.3;
      z-index: 60;
      pointer-events: none;
    }
    .event-log-title {
      text-transform: uppercase;
      letter-spacing: .08em;
      opacity: .7;
      margin-bottom: 4px;
    }
    .event-log-list {
      max-height: 90px;
      overflow: hidden;
    }
    .event-log-item {
      opacity: .9;
      margin-bottom: 2px;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    /* Modals g√©n√©riques pour ressources / journal / entropie */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.65);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 300;
    }
    .modal {
      min-width: 260px;
      max-width: 420px;
      max-height: 80vh;
      padding: 14px 16px;
      border-radius: 18px;
      background: rgba(10,8,30,0.96);
      border: 1px solid rgba(0,255,255,0.4);
      backdrop-filter: blur(22px);
      -webkit-backdrop-filter: blur(22px);
      box-shadow: 0 0 26px rgba(0,255,255,0.7);
      font-size: 13px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .modal-title {
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: .09em;
      opacity: .85;
    }
    .modal-close {
      border: none;
      background: transparent;
      color: #7ffcff;
      font-size: 16px;
      cursor: pointer;
    }
    .modal-body {
      font-size: 12px;
      overflow-y: auto;
    }
    .modal-body p { margin-bottom: 6px; }
    .modal-body ul { padding-left: 16px; margin: 4px 0 8px; }
    .modal-body li { margin-bottom: 3px; }

    @media (max-width: 600px) {
      .hud {
        padding: 8px 10px;
        font-size: 11px;
      }
      .hud span.value {
        font-size: 12px;
      }
      #hud-tl { top: 8px; left: 8px; }
      #hud-tr { top: 8px; right: 8px; }
      #hud-bl { bottom: 8px; left: 8px; }
      #hud-br { bottom: 8px; right: 8px; }

      .panel {
        width: 220px;
        right: 8px;
        top: 96px;
      }
      .event-log {
        width: 70%;
        left: 8px;
        bottom: 64px;
      }
      .modal {
        width: 90%;
        max-width: 90%;
      }
    }

    @media (max-height: 500px) {
      .hud {
        padding: 6px 8px;
        border-radius: 12px;
      }
      .event-log {
        bottom: 56px;
      }
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <!-- HUD 4 coins -->
  <div id="hud-tl" class="hud">
    <span class="label">Ressources</span>
    <span class="value" id="hud-res">üß± 0 (+0/s) ¬∑ ‚ö° 0 (+0/s)</span>
  </div>
  <div id="hud-tr" class="hud">
    <span class="label">Rang & Prestige</span>
    <span class="value" id="hud-rank">NIV 1 ¬∑ P0</span>
    <div id="hud-prestige-zone"></div>
  </div>
  <div id="hud-bl" class="hud">
    <span class="label">Temps</span>
    <span class="value" id="hud-time">0.0 s</span>
  </div>
  <div id="hud-br" class="hud">
    <span class="label">Entropie & Chaleur</span>
    <span class="value" id="hud-entropy">0 % ¬∑ Heat 0%</span>
  </div>

  <!-- Mini journal bas gauche -->
  <div class="event-log" id="eventLog">
    <div class="event-log-title">Journal</div>
    <div class="event-log-list" id="eventLogList"></div>
  </div>

  <!-- Menu d√©tail / upgrade machine -->
  <div class="contextMenu" id="contextMenu">
    <h4 id="ctx-title">Machine</h4>
    <div class="info" id="ctx-info"></div>
    <div class="info" id="ctx-module"></div>
    <div class="info" id="ctx-heat"></div>
    <button id="ctx-upgrade">Am√©liorer</button>
    <button id="ctx-module-btn">Installer module</button>
    <button id="ctx-delete-btn" style="border-color:rgba(255,80,80,0.9);color:#ffd0d0;">Supprimer</button>
    <div class="cost" id="ctx-cost"></div>
  </div>

  <!-- Menu placement machine (clic gauche sur cellule vide) -->
  <div class="contextMenu" id="placeMenu">
    <h4>Placer une machine</h4>
    <button data-place="extractor">üß± Extracteur</button>
    <button data-place="generator">‚ö° G√©n√©rateur</button>
    <button data-place="miner">‚õèÔ∏è Mineur</button>
    <button data-place="altar">üú® Autel</button>
  </div>

  <!-- Panel arbre techno -->
  <div class="panel" id="techPanel">
    <h3>Arbre technologique</h3>
    <div id="techList"></div>
    <div style="margin-top:6px; font-size:11px; opacity:.8;">
      Touche <b>T</b> pour ouvrir/fermer.
    </div>
  </div>

  <!-- Modal ressources + rang/prestige -->
  <div class="modal-backdrop" id="modalResBackdrop">
    <div class="modal">
      <div class="modal-header">
        <div class="modal-title">Ressources & Rang</div>
        <button class="modal-close" data-close-res>&times;</button>
      </div>
      <div class="modal-body" id="modalResBody">
        <!-- Rempli dynamiquement -->
      </div>
    </div>
  </div>

  <!-- Modal journal complet (ouvert via HUD temps) -->
  <div class="modal-backdrop" id="modalJournalBackdrop">
    <div class="modal">
      <div class="modal-header">
        <div class="modal-title">Journal d'√©v√©nements</div>
        <button class="modal-close" data-close-journal>&times;</button>
      </div>
      <div class="modal-body" id="modalJournalBody">
        <!-- Rempli dynamiquement -->
      </div>
    </div>
  </div>

  <!-- Modal entropie & chaleur -->
  <div class="modal-backdrop" id="modalEntropyBackdrop">
    <div class="modal">
      <div class="modal-header">
        <div class="modal-title">Entropie & Chaleur</div>
        <button class="modal-close" data-close-entropy>&times;</button>
      </div>
      <div class="modal-body" id="modalEntropyBody">
        <!-- Rempli dynamiquement -->
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const HUD_RES = document.getElementById('hud-res');
    const HUD_RANK = document.getElementById('hud-rank');
    const HUD_TIME = document.getElementById('hud-time');
    const HUD_ENTROPY = document.getElementById('hud-entropy');
    const HUD_PRESTIGE_ZONE = document.getElementById('hud-prestige-zone');

    const HUD_TL = document.getElementById('hud-tl');
    const HUD_TR = document.getElementById('hud-tr');
    const HUD_BL = document.getElementById('hud-bl');
    const HUD_BR = document.getElementById('hud-br');

    const contextMenu = document.getElementById('contextMenu');
    const ctxTitle = document.getElementById('ctx-title');
    const ctxInfo = document.getElementById('ctx-info');
    const ctxModuleInfo = document.getElementById('ctx-module');
    const ctxHeatInfo = document.getElementById('ctx-heat');
    const ctxCost = document.getElementById('ctx-cost');
    const ctxUpgradeBtn = document.getElementById('ctx-upgrade');
    const ctxModuleBtn = document.getElementById('ctx-module-btn');
    const ctxDeleteBtn = document.getElementById('ctx-delete-btn');

    const placeMenu = document.getElementById('placeMenu');

    const techPanel = document.getElementById('techPanel');
    const techListEl = document.getElementById('techList');

    const eventLogEl = document.getElementById('eventLogList');

    const modalResBackdrop = document.getElementById('modalResBackdrop');
    const modalResBody = document.getElementById('modalResBody');
    const modalJournalBackdrop = document.getElementById('modalJournalBackdrop');
    const modalJournalBody = document.getElementById('modalJournalBody');
    const modalEntropyBackdrop = document.getElementById('modalEntropyBackdrop');
    const modalEntropyBody = document.getElementById('modalEntropyBody');

    const GRID_SIZE = 10;
    let CELL_SIZE = 40;
    let gridStartX = 0;
    let gridStartY = 0;

    const RES = {
      matter: 0,
      energy: 0,
      matterRate: 0,
      energyRate: 0,
      entropy: 0
    };

    const game = {
      time: 0,
      lastTime: 0,
      running: true,
      rankLevel: 1,
      prestigeCount: 0,
      prestigeBonus: 1,
      particles: [],
      machines: [],
      grid: [],
      contextTargetIndex: null,
      avgHeat: 0
    };

    const MACHINES = {
      extractor: { id:'extractor', name:'Extracteur', icon:'üß±', matter:1,   energy:0,   color:'#00ffff' },
      generator: { id:'generator', name:'G√©n√©rateur', icon:'‚ö°',  matter:0,   energy:2,   color:'#ffcc00' },
      miner:     { id:'miner',     name:'Mineur',     icon:'‚õèÔ∏è', matter:1.8, energy:-0.5,color:'#ff6600' },
      altar:     { id:'altar',     name:'Autel',      icon:'üú®', matter:1.2, energy:0,   color:'#a18bff' }
    };

    const MODULES = [
      { id:'catalyst',   name:'Catalyseur',   desc:'+25% mati√®re',              rarity:'common',    matterMult:1.25, energyMult:1,    entropyMult:1 },
      { id:'capacitor',  name:'Condensateur', desc:'+25% √©nergie',              rarity:'common',    matterMult:1,    energyMult:1.25, entropyMult:1 },
      { id:'stabilizer', name:'Stabilisateur',desc:'-20% entropie g√©n√©r√©e',     rarity:'rare',      matterMult:1,    energyMult:1,    entropyMult:0.8 },
      { id:'hyperflux',  name:'Hyperflux',    desc:'+100% prod, +50% entropie', rarity:'epic',      matterMult:2,    energyMult:2,    entropyMult:1.5 },
      { id:'singularity',name:'Singularit√©',  desc:'Double prod globale',       rarity:'legendary', matterMult:2,    energyMult:2,    entropyMult:1.2, global:true }
    ];

    const TECHS = [
      {
        id:'opt_mine',
        name:'Optimisation mini√®re',
        desc:'+10% mati√®re globale',
        cost:{matter:500, energy:200, entropy:5},
        effect:(s)=>{ s.techMatterMult *= 1.10; }
      },
      {
        id:'coil',
        name:'Bobines quantiques',
        desc:'+20% √©nergie globale',
        cost:{matter:400, energy:400, entropy:5},
        effect:(s)=>{ s.techEnergyMult *= 1.20; }
      },
      {
        id:'cryo',
        name:'Refroidissement cryo',
        desc:'-30% chaleur g√©n√©r√©e',
        cost:{matter:600, energy:300, entropy:8},
        effect:(s)=>{ s.heatMult *= 0.7; }
      },
      {
        id:'stability',
        name:'Stabilit√© dimensionnelle',
        desc:'Entropie max 150%',
        cost:{matter:800, energy:600, entropy:10},
        effect:(s)=>{ s.entropyMax = 150; }
      },
      {
        id:'neural',
        name:'R√©seau neural',
        desc:'+1 module par machine',
        cost:{matter:1200, energy:900, entropy:15},
        effect:(s)=>{ s.maxModulesPerMachine = 2; }
      }
    ];

    const techState = {
      unlocked: new Set(),
      techMatterMult: 1,
      techEnergyMult: 1,
      heatMult: 1,
      entropyMax: 100,
      maxModulesPerMachine: 1
    };

    const notifications = [];
    const burstParticles = [];
    const eventLog = [];

    let audioCtx = null;

    /* ---------- INITIALISATION GRILLE & PARTICULES ---------- */

    function initGrid() {
      game.grid = [];
      for (let y = 0; y < GRID_SIZE; y++) {
        const row = [];
        for (let x = 0; x < GRID_SIZE; x++) row.push(null);
        game.grid.push(row);
      }
    }

    function initParticles() {
      game.particles = [];
      for (let i = 0; i < 120; i++) {
        game.particles.push({
          x: Math.random(),
          y: Math.random(),
          vx: (Math.random() - 0.5) * 0.02,
          vy: (Math.random() - 0.5) * 0.02,
          r: 0.0015 + Math.random() * 0.004,
          phase: Math.random() * Math.PI * 2
        });
      }
    }

    /* ---------- RESPONSIVE CANVAS & GRILLE ---------- */

    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      const minDim = Math.min(rect.width, rect.height);
      CELL_SIZE = (minDim * 0.75) / GRID_SIZE;

      const gridWidth = CELL_SIZE * GRID_SIZE;
      const gridHeight = CELL_SIZE * GRID_SIZE;
      gridStartX = (rect.width - gridWidth) / 2;
      gridStartY = (rect.height - gridHeight) / 2;

      // Recalcule la position des machines pour qu'elles restent centr√©es sur leurs cellules
      for (const m of game.machines) {
        if (!m || m.deleted) continue;
        const c = getCellCenter(m.gx, m.gy);
        m.x = c.x;
        m.y = c.y;
      }
    }
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('orientationchange', () => {
      setTimeout(resizeCanvas, 200);
    });

    function screenToGrid(x, y) {
      const rect = canvas.getBoundingClientRect();
      const localX = x - rect.left;
      const localY = y - rect.top;
      const gx = Math.floor((localX - gridStartX) / CELL_SIZE);
      const gy = Math.floor((localY - gridStartY) / CELL_SIZE);
      if (gx < 0 || gy < 0 || gx >= GRID_SIZE || gy >= GRID_SIZE) return null;
      return { gx, gy };
    }

    function getCellCenter(gx, gy) {
      return {
        x: gridStartX + gx * CELL_SIZE + CELL_SIZE / 2,
        y: gridStartY + gy * CELL_SIZE + CELL_SIZE / 2
      };
    }

    function getMachineAtGrid(gx, gy) {
      const idx = game.grid[gy][gx];
      if (idx === null || idx === undefined) return null;
      const m = game.machines[idx];
      if (!m || m.deleted) return null;
      return { index: idx, machine: m };
    }

    function placeMachineAt(gx, gy, typeId) {
      if (game.grid[gy][gx] !== null) return;
      const def = MACHINES[typeId];
      if (!def) return;
      const center = getCellCenter(gx, gy);
      const machine = {
        type: typeId,
        x: center.x,
        y: center.y,
        gx, gy,
        level: 1,
        rot: 0,
        pulse: Math.random() * Math.PI * 2,
        modules: [],
        heat: 0,
        deleted: false
      };
      const index = game.machines.length;
      game.machines.push(machine);
      game.grid[gy][gx] = index;
      addEvent(`Nouvelle machine : ${def.name}`);
    }

    /* ---------- DESSIN DES MACHINES ---------- */

    function drawExtractor(x, y, r, rot, color, pulseScale) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rot);
      ctx.scale(pulseScale, pulseScale);
      ctx.beginPath();
      ctx.moveTo(0, -r);
      ctx.lineTo(-r * 0.8, r * 0.7);
      ctx.lineTo(r * 0.8, r * 0.7);
      ctx.closePath();
      ctx.strokeStyle = color;
      ctx.fillStyle = 'rgba(0,255,255,0.12)';
      ctx.stroke(); ctx.fill();
      ctx.restore();
    }

    function drawGenerator(x, y, r, rot, color, pulseScale) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rot);
      ctx.scale(pulseScale, pulseScale);
      const sides = 6;
      ctx.beginPath();
      for (let i = 0; i < sides; i++) {
        const a = (i / sides) * Math.PI * 2;
        const px = Math.cos(a) * r;
        const py = Math.sin(a) * r;
        if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.strokeStyle = color;
      ctx.fillStyle = 'rgba(255,204,0,0.15)';
      ctx.stroke(); ctx.fill();
      ctx.restore();
    }

    function drawMiner(x, y, r, rot, color, pulseScale) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rot);
      ctx.scale(pulseScale, pulseScale);
      ctx.beginPath();
      ctx.arc(0, 0, r * 0.6, 0, Math.PI * 2);
      ctx.strokeStyle = color;
      ctx.fillStyle = 'rgba(255,102,0,0.18)';
      ctx.stroke(); ctx.fill();
      const rays = 8;
      for (let i = 0; i < rays; i++) {
        const a = (i / rays) * Math.PI * 2;
        const inner = r * 0.6;
        const outer = r * 1.1;
        ctx.beginPath();
        ctx.moveTo(Math.cos(a) * inner, Math.sin(a) * inner);
        ctx.lineTo(Math.cos(a) * outer, Math.sin(a) * outer);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawAltar(x, y, r, rot, color, pulseScale) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rot);
      ctx.scale(pulseScale, pulseScale);
      ctx.beginPath();
      ctx.arc(0, 0, r * 0.7, 0, Math.PI * 2);
      ctx.strokeStyle = color;
      ctx.fillStyle = 'rgba(161,139,255,0.20)';
      ctx.stroke(); ctx.fill();
      const rays = 6;
      for (let i = 0; i < rays; i++) {
        const a = (i / rays) * Math.PI * 2;
        const inner = r * 0.7;
        const outer = r * 1.2;
        ctx.beginPath();
        ctx.moveTo(Math.cos(a) * inner, Math.sin(a) * inner);
        ctx.lineTo(Math.cos(a) * outer, Math.sin(a) * outer);
        ctx.stroke();
      }
      ctx.restore();
    }

    /* ---------- MENUS CONTEXTUELS & INTERACTION GRILLE ---------- */

    function hideContextMenu() {
      contextMenu.style.display = 'none';
      game.contextTargetIndex = null;
    }
    function hidePlaceMenu() {
      placeMenu.style.display = 'none';
    }

    function showPlaceMenu(x, y, gx, gy) {
      hideContextMenu();
      const rect = canvas.getBoundingClientRect();
      let px = x, py = y;
      const mw = 180, mh = 140;
      if (px + mw > rect.right) px = rect.right - mw - 8;
      if (py + mh > rect.bottom) py = rect.bottom - mh - 8;
      placeMenu.style.left = px + 'px';
      placeMenu.style.top = py + 'px';
      placeMenu.style.display = 'block';

      placeMenu.querySelectorAll('button[data-place]').forEach(btn => {
        btn.onclick = () => {
          const type = btn.getAttribute('data-place');
          placeMachineAt(gx, gy, type);
          hidePlaceMenu();
        };
      });
    }

    function handlePrimaryPointer(clientX, clientY) {
      const cell = screenToGrid(clientX, clientY);
      if (!cell) {
        hideContextMenu();
        hidePlaceMenu();
        return;
      }
      const { gx, gy } = cell;
      const existing = getMachineAtGrid(gx, gy);
      if (existing) {
        hidePlaceMenu();
        showContextMenuFor(existing.index, clientX, clientY);
      } else {
        hideContextMenu();
        showPlaceMenu(clientX, clientY, gx, gy);
      }
    }

    function handleSecondaryPointer(clientX, clientY) {
      const cell = screenToGrid(clientX, clientY);
      if (!cell) {
        hideContextMenu();
        hidePlaceMenu();
        return;
      }
      const { gx, gy } = cell;
      const existing = getMachineAtGrid(gx, gy);
      if (existing) {
        hidePlaceMenu();
        showContextMenuFor(existing.index, clientX, clientY);
      } else {
        hideContextMenu();
        showPlaceMenu(clientX, clientY, gx, gy);
      }
    }

    canvas.addEventListener('click', e => {
      handlePrimaryPointer(e.clientX, e.clientY);
    });

    canvas.addEventListener('contextmenu', e => {
      e.preventDefault();
      handleSecondaryPointer(e.clientX, e.clientY);
    });

    canvas.addEventListener('touchstart', e => {
      if (e.touches.length > 0) {
        const t = e.touches[0];
        handlePrimaryPointer(t.clientX, t.clientY);
      }
    }, { passive: false });

    document.addEventListener('click', e => {
      if (e.target === canvas) return;
      if (!contextMenu.contains(e.target) && !placeMenu.contains(e.target)) {
        hideContextMenu();
        hidePlaceMenu();
      }
    });

    function rarityClass(r) {
      if (r === 'rare') return 'rarity-rare';
      if (r === 'epic') return 'rarity-epic';
      if (r === 'legendary') return 'rarity-legendary';
      return 'rarity-common';
    }

    function showContextMenuFor(machineIndex, clientX, clientY) {
      game.contextTargetIndex = machineIndex;
      const m = game.machines[machineIndex];
      if (!m || m.deleted) return;
      const def = MACHINES[m.type];
      const level = m.level;
      const mult = 1 + level * 0.5;
      const cost = level * 75;

      ctxTitle.textContent = `${def.icon} ${def.name}`;
      ctxInfo.textContent = `Niveau ${level} ¬∑ Mult x${mult.toFixed(2)}`;

      if (m.modules.length) {
        const parts = m.modules.map(mod => {
          return `<span class="${rarityClass(mod.rarity)}">${mod.name}</span>`;
        });
        ctxModuleInfo.innerHTML = `Modules : ${parts.join(', ')}`;
      } else {
        ctxModuleInfo.textContent = 'Modules : Aucun';
      }

      ctxHeatInfo.textContent = `Chaleur : ${m.heat.toFixed(0)}%`;
      ctxCost.textContent = `Co√ªt am√©lioration : ${cost} ‚ö°`;

      const rect = canvas.getBoundingClientRect();
      let x = clientX, y = clientY;
      const mw = 220, mh = 190;
      if (x + mw > rect.right) x = rect.right - mw - 8;
      if (y + mh > rect.bottom) y = rect.bottom - mh - 8;
      contextMenu.style.left = x + 'px';
      contextMenu.style.top = y + 'px';
      contextMenu.style.display = 'block';
    }

    /* ---------- ACTIONS CONTEXT MENU (UPGRADE / MODULE / DELETE) ---------- */

    ctxUpgradeBtn.addEventListener('click', () => {
      const idx = game.contextTargetIndex;
      if (idx === null || idx === undefined) return;
      const m = game.machines[idx];
      if (!m || m.deleted) return;
      const cost = m.level * 75;
      if (RES.energy < cost) return;
      RES.energy -= cost;
      m.level++;
      const def = MACHINES[m.type];
      const mult = 1 + m.level * 0.5;
      ctxInfo.textContent = `Niveau ${m.level} ¬∑ Mult x${mult.toFixed(2)}`;
      ctxCost.textContent = `Co√ªt am√©lioration : ${m.level * 75} ‚ö°`;
      addNotification(m.x, m.y - CELL_SIZE * 0.6, 'Niveau +1 !');
      spawnBurst(m.x, m.y);
      playLevelSound();
      addEvent(`Am√©lioration : ${def.name} niveau ${m.level}`);
      hideContextMenu();
    });

    function rollModule() {
      const weights = [40, 40, 12, 6, 2];
      const total = weights.reduce((a,b)=>a+b,0);
      let r = Math.random() * total;
      for (let i = 0; i < MODULES.length; i++) {
        if (r < weights[i]) return MODULES[i];
        r -= weights[i];
      }
      return MODULES[0];
    }

    ctxModuleBtn.addEventListener('click', () => {
      const idx = game.contextTargetIndex;
      if (idx === null || idx === undefined) return;
      const m = game.machines[idx];
      if (!m || m.deleted) return;
      if (m.modules.length >= techState.maxModulesPerMachine) return;
      const mod = rollModule();
      m.modules.push(mod);
      addNotification(m.x, m.y - CELL_SIZE * 0.4, mod.name);
      spawnBurst(m.x, m.y);
      addEvent(`Module install√© : ${mod.name}`);
      hideContextMenu();
    });

    // Suppression de la machine (clic sur "Supprimer")
    ctxDeleteBtn.addEventListener('click', () => {
      const idx = game.contextTargetIndex;
      if (idx === null || idx === undefined) return;
      const m = game.machines[idx];
      if (!m || m.deleted) return;
      game.grid[m.gy][m.gx] = null;
      m.deleted = true;
      addEvent(`Machine supprim√©e : ${MACHINES[m.type].name}`);
      hideContextMenu();
    });

    /* ---------- ARBRE TECHNO ---------- */

    function canAfford(cost) {
      return RES.matter >= cost.matter &&
             RES.energy >= cost.energy &&
             RES.entropy >= cost.entropy;
    }

    function payCost(cost) {
      RES.matter -= cost.matter;
      RES.energy -= cost.energy;
      RES.entropy -= cost.entropy;
    }

    function buildTechUI() {
      techListEl.innerHTML = '';
      TECHS.forEach(tech => {
        const div = document.createElement('div');
        div.className = 'tech locked';
        if (techState.unlocked.has(tech.id)) div.className = 'tech unlocked';
        div.dataset.id = tech.id;

        const title = document.createElement('div');
        title.className = 'tech-title';
        title.textContent = tech.name;

        const desc = document.createElement('div');
        desc.className = 'tech-desc';
        desc.textContent = tech.desc;

        const cost = document.createElement('div');
        cost.className = 'tech-cost';
        cost.textContent = `Co√ªt: üß±${tech.cost.matter} ¬∑ ‚ö°${tech.cost.energy} ¬∑ üå™${tech.cost.entropy}`;

        div.appendChild(title);
        div.appendChild(desc);
        div.appendChild(cost);

        div.addEventListener('click', () => {
          if (techState.unlocked.has(tech.id)) return;
          if (!canAfford(tech.cost)) return;
          payCost(tech.cost);
          techState.unlocked.add(tech.id);
          tech.effect(techState);
          addEvent(`Technologie d√©bloqu√©e : ${tech.name}`);
          buildTechUI();
        });

        techListEl.appendChild(div);
      });
    }

    document.addEventListener('keydown', e => {
      if (e.key === 't' || e.key === 'T') {
        techPanel.style.display = techPanel.style.display === 'none' ? 'block' : 'none';
      }
    });

    /* ---------- PRESTIGE ---------- */

    function tryPrestige() {
      const can =
        RES.matter >= 1_000_000 &&
        RES.energy >= 500_000 &&
        RES.entropy >= 90;
      if (!can) return;
      game.prestigeCount++;
      game.prestigeBonus = 1 + game.prestigeCount * 0.01;

      RES.matter = 0;
      RES.energy = 0;
      RES.entropy = 0;
      game.time = 0;
      game.rankLevel = 1;
      game.machines = [];
      initGrid();

      techState.unlocked.clear();
      techState.techMatterMult = 1;
      techState.techEnergyMult = 1;
      techState.heatMult = 1;
      techState.entropyMax = 100;
      techState.maxModulesPerMachine = 1;
      buildTechUI();
      addEvent(`Prestige ${game.prestigeCount} activ√©`);
    }

    /* ---------- NOTIFS, PARTICULES DE LEVELING & JOURNAL ---------- */

    function addNotification(x, y, text) {
      notifications.push({ x, y, text, alpha: 1, life: 1 });
    }

    function spawnBurst(x, y) {
      for (let i = 0; i < 24; i++) {
        const a = Math.random() * Math.PI * 2;
        const s = 40 + Math.random() * 60;
        burstParticles.push({
          x, y,
          vx: Math.cos(a) * s,
          vy: Math.sin(a) * s,
          life: 0.6,
          alpha: 1
        });
      }
    }

    function addEvent(text) {
      const t = `[${game.time.toFixed(1)}s] ${text}`;
      eventLog.unshift(t);
      if (eventLog.length > 20) eventLog.pop();
      eventLogEl.innerHTML = '';
      eventLog.forEach(e => {
        const div = document.createElement('div');
        div.className = 'event-log-item';
        div.textContent = e;
        eventLogEl.appendChild(div);
      });
    }

    function playLevelSound() {
      try {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const ctxA = audioCtx;
        const osc = ctxA.createOscillator();
        const gain = ctxA.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(880, ctxA.currentTime);
        osc.frequency.linearRampToValueAtTime(1320, ctxA.currentTime + 0.15);
        gain.gain.setValueAtTime(0.0, ctxA.currentTime);
        gain.gain.linearRampToValueAtTime(0.2, ctxA.currentTime + 0.02);
        gain.gain.linearRampToValueAtTime(0.0, ctxA.currentTime + 0.18);
        osc.connect(gain);
        gain.connect(ctxA.destination);
        osc.start();
        osc.stop(ctxA.currentTime + 0.2);
      } catch(e) {}
    }

    /* ---------- MODALS (RESSOURCES / JOURNAL / ENTROPIE) ---------- */

    function openResModal() {
      modalResBody.innerHTML = `
        <p><b>Ressources actuelles</b></p>
        <ul>
          <li>Mati√®re : ${RES.matter.toFixed(1)} ( +${RES.matterRate.toFixed(1)}/s )</li>
          <li>√ânergie : ${RES.energy.toFixed(1)} ( +${RES.energyRate.toFixed(1)}/s )</li>
          <li>Entropie : ${RES.entropy.toFixed(1)} / ${techState.entropyMax}</li>
        </ul>
        <p><b>Rang & Prestige</b></p>
        <ul>
          <li>Rang actuel : ${game.rankLevel}</li>
          <li>Prestiges : ${game.prestigeCount}</li>
          <li>Bonus prestige global : x${game.prestigeBonus.toFixed(2)}</li>
        </ul>
        <!-- FUTUR : ajouter ici les statistiques avanc√©es (production cumul√©e, meilleurs modules, etc.) -->
      `;
      modalResBackdrop.style.display = 'flex';
    }

    function openJournalModal() {
      modalJournalBody.innerHTML = '';
      const p = document.createElement('p');
      p.innerHTML = '<b>Historique complet</b>';
      modalJournalBody.appendChild(p);
      const ul = document.createElement('ul');
      eventLog.forEach(e => {
        const li = document.createElement('li');
        li.textContent = e;
        ul.appendChild(li);
      });
      modalJournalBody.appendChild(ul);
      // FUTUR : filtrage par type d‚Äô√©v√©nement, recherche, tags...
      modalJournalBackdrop.style.display = 'flex';
    }

    function openEntropyModal() {
      modalEntropyBody.innerHTML = `
        <p><b>Entropie</b></p>
        <p>L'entropie repr√©sente le chaos du r√©seau. Plus elle est √©lev√©e, plus les effets de surcharge et de p√©nalit√© peuvent appara√Ætre.</p>
        <ul>
          <li>Entropie actuelle : ${RES.entropy.toFixed(1)} / ${techState.entropyMax}</li>
          <li>Chaleur moyenne : ${game.avgHeat.toFixed(1)}%</li>
        </ul>
        <p><b>Chaleur</b></p>
        <p>Chaque machine g√©n√®re de la chaleur en fonction de sa production. Au-del√† de 100%, la production est r√©duite et l'entropie augmente plus vite.</p>
        <!-- FUTUR : ajouter un mini-graphique de chaleur par machine, et des upgrades de refroidissement -->
      `;
      modalEntropyBackdrop.style.display = 'flex';
    }

    // Clics HUD -> ouverture modals
    HUD_TL.addEventListener('click', e => {
      e.stopPropagation();
      openResModal();
    });
    HUD_TR.addEventListener('click', e => {
      e.stopPropagation();
      openResModal();
    });
    HUD_BL.addEventListener('click', e => {
      e.stopPropagation();
      openJournalModal();
    });
    HUD_BR.addEventListener('click', e => {
      e.stopPropagation();
      openEntropyModal();
    });

    // Fermeture modals
    modalResBackdrop.addEventListener('click', e => {
      if (e.target === modalResBackdrop) modalResBackdrop.style.display = 'none';
    });
    modalJournalBackdrop.addEventListener('click', e => {
      if (e.target === modalJournalBackdrop) modalJournalBackdrop.style.display = 'none';
    });
    modalEntropyBackdrop.addEventListener('click', e => {
      if (e.target === modalEntropyBackdrop) modalEntropyBackdrop.style.display = 'none';
    });
    document.querySelector('[data-close-res]').addEventListener('click', () => {
      modalResBackdrop.style.display = 'none';
    });
    document.querySelector('[data-close-journal]').addEventListener('click', () => {
      modalJournalBackdrop.style.display = 'none';
    });
    document.querySelector('[data-close-entropy]').addEventListener('click', () => {
      modalEntropyBackdrop.style.display = 'none';
    });

    /* ---------- BOUCLE DE SIMULATION ---------- */

    function update(dt) {
      for (const p of game.particles) {
        p.phase += dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        if (p.x < 0) p.x += 1;
        if (p.x > 1) p.x -= 1;
        if (p.y < 0) p.y += 1;
        if (p.y > 1) p.y -= 1;
      }

      for (let i = notifications.length - 1; i >= 0; i--) {
        const n = notifications[i];
        n.life -= dt;
        n.y -= 20 * dt;
        n.alpha = n.life;
        if (n.life <= 0) notifications.splice(i, 1);
      }

      for (let i = burstParticles.length - 1; i >= 0; i--) {
        const b = burstParticles[i];
        b.life -= dt;
        b.x += b.vx * dt;
        b.y += b.vy * dt;
        b.vx *= 0.9;
        b.vy *= 0.9;
        b.alpha = b.life / 0.6;
        if (b.life <= 0) burstParticles.splice(i, 1);
      }

      let matterRate = 0;
      let energyRate = 0;
      let entropyGain = 0;
      let totalHeat = 0;

      let globalModuleMatterMult = 1;
      let globalModuleEnergyMult = 1;
      for (const m of game.machines) {
        if (!m || m.deleted) continue;
        for (const mod of m.modules) {
          if (mod.global) {
            globalModuleMatterMult *= mod.matterMult;
            globalModuleEnergyMult *= mod.energyMult;
          }
        }
      }

      for (const m of game.machines) {
        if (!m || m.deleted) continue;
        const def = MACHINES[m.type];
        const levelMult = 1 + m.level * 0.5;

        let localMatterMult = 1;
        let localEnergyMult = 1;
        let localEntropyMult = 1;

        for (const mod of m.modules) {
          if (mod.global) continue;
          localMatterMult *= mod.matterMult;
          localEnergyMult *= mod.energyMult;
          localEntropyMult *= mod.entropyMult;
        }

        let mMatter = def.matter * levelMult * localMatterMult;
        let mEnergy = def.energy * levelMult * localEnergyMult;

        mMatter *= techState.techMatterMult * game.prestigeBonus * globalModuleMatterMult;
        mEnergy *= techState.techEnergyMult * game.prestigeBonus * globalModuleEnergyMult;

        let machineEntropy = 0.2 * localEntropyMult;

        const prodMagnitude = Math.abs(mMatter) + Math.abs(mEnergy);
        let heatGain = prodMagnitude * 0.05 * techState.heatMult;
        m.heat += heatGain * dt;
        m.heat -= 5 * dt;
        if (m.heat < 0) m.heat = 0;
        if (m.heat > 150) m.heat = 150;

        if (m.heat > 100) {
          mMatter *= 0.5;
          mEnergy *= 0.5;
          machineEntropy *= 1.5;
        }

        matterRate += mMatter;
        energyRate += mEnergy;
        entropyGain += machineEntropy;
        totalHeat += m.heat;

        m.rot += dt * 0.6;
        m.pulse += dt * 2.0;
      }

      game.avgHeat = game.machines.length ? totalHeat / game.machines.length : 0;

      RES.matterRate = matterRate;
      RES.energyRate = energyRate;

      RES.matter += matterRate * dt;
      RES.energy += energyRate * dt;

      RES.entropy += entropyGain * dt;
      if (RES.entropy > techState.entropyMax) RES.entropy = techState.entropyMax;
      if (RES.entropy < 0) RES.entropy = 0;

      const needed = game.rankLevel * 200;
      if (RES.matter >= needed) game.rankLevel++;

      game.time += dt;
    }

    /* ---------- RENDU ---------- */

    function render() {
      const rect = canvas.getBoundingClientRect();
      const w = rect.width;
      const h = rect.height;

      ctx.clearRect(0, 0, w, h);

      ctx.save();
      ctx.fillStyle = 'rgba(5,7,15,0.9)';
      ctx.fillRect(0, 0, w, h);
      ctx.globalCompositeOperation = 'lighter';
      for (const p of game.particles) {
        const x = p.x * w;
        const y = p.y * h;
        const r = p.r * Math.min(w, h) * (1 + 0.4 * Math.sin(p.phase));
        const grad = ctx.createRadialGradient(x, y, 0, x, y, r);
        grad.addColorStop(0, 'rgba(127,252,255,0.9)');
        grad.addColorStop(1, 'rgba(127,252,255,0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();

      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.03)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let i = 0; i <= GRID_SIZE; i++) {
        const gx = gridStartX + i * CELL_SIZE;
        ctx.moveTo(gx, gridStartY);
        ctx.lineTo(gx, gridStartY + GRID_SIZE * CELL_SIZE);
      }
      for (let j = 0; j <= GRID_SIZE; j++) {
        const gy = gridStartY + j * CELL_SIZE;
        ctx.moveTo(gridStartX, gy);
        ctx.lineTo(gridStartX + GRID_SIZE * CELL_SIZE, gy);
      }
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.strokeStyle = 'rgba(127,252,255,0.18)';
      ctx.lineWidth = 1.4;
      ctx.shadowColor = 'rgba(127,252,255,0.7)';
      ctx.shadowBlur = 12;
      for (let i = 0; i < game.machines.length; i++) {
        const mi = game.machines[i];
        if (!mi || mi.deleted) continue;
        const defi = MACHINES[mi.type];
        if (defi.energy <= 0) continue;
        for (let j = i + 1; j < game.machines.length; j++) {
          const mj = game.machines[j];
          if (!mj || mj.deleted) continue;
          const defj = MACHINES[mj.type];
          if (defj.energy <= 0) continue;
          const dx = mi.x - mj.x;
          const dy = mi.y - mj.y;
          const dist = Math.hypot(dx, dy);
          if (dist < CELL_SIZE * 3.2) {
            const alpha = 0.25 * (1 - dist / (CELL_SIZE * 3.2));
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.moveTo(mi.x, mi.y);
            ctx.lineTo(mj.x, mj.y);
            ctx.stroke();
          }
        }
      }
      ctx.restore();

      const blurBase = 28;
      const blurExtra = (RES.entropy / techState.entropyMax) * 25;
      const lineBase = 2.8;
      const lineExtra = RES.entropy / techState.entropyMax;

      ctx.save();
      ctx.lineWidth = lineBase + lineExtra;
      ctx.shadowBlur = blurBase + blurExtra;
      ctx.shadowColor = 'rgba(0,255,255,0.8)';
      for (const m of game.machines) {
        if (!m || m.deleted) continue;
        const def = MACHINES[m.type];
        const r = CELL_SIZE * 0.32;
        const pulseScale = 1 + Math.sin(m.pulse) * 0.15;
        let color = def.color;
        if (m.modules.some(mod => mod.rarity === 'legendary')) color = '#ffd700';
        else if (m.modules.some(mod => mod.rarity === 'epic')) color = '#ff7fff';
        else if (m.modules.some(mod => mod.rarity === 'rare')) color = '#7ffcff';
        if (m.heat > 100) color = '#ff4444';
        switch (m.type) {
          case 'extractor': drawExtractor(m.x, m.y, r, m.rot, color, pulseScale); break;
          case 'generator': drawGenerator(m.x, m.y, r, m.rot, color, pulseScale); break;
          case 'miner':     drawMiner(m.x, m.y, r, m.rot, color, pulseScale); break;
          case 'altar':     drawAltar(m.x, m.y, r, m.rot, color, pulseScale); break;
        }
      }
      ctx.restore();

      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for (const b of burstParticles) {
        ctx.globalAlpha = b.alpha;
        ctx.fillStyle = 'rgba(127,252,255,0.9)';
        ctx.beginPath();
        ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();

      ctx.save();
      ctx.font = '16px "Segoe UI",system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      for (const n of notifications) {
        ctx.globalAlpha = n.alpha;
        ctx.fillStyle = '#7ffcff';
        ctx.fillText(n.text, n.x, n.y);
      }
      ctx.restore();
    }

    /* ---------- HUD UPDATE ---------- */

    function updateUI() {
      HUD_RES.textContent =
        `üß± ${RES.matter.toFixed(1)} (+${RES.matterRate.toFixed(1)}/s) ¬∑ ` +
        `‚ö° ${RES.energy.toFixed(1)} (+${RES.energyRate.toFixed(1)}/s)`;
      HUD_RANK.textContent = `NIV ${game.rankLevel} ¬∑ P${game.prestigeCount}`;
      HUD_TIME.textContent = `${game.time.toFixed(1)} s`;
      HUD_ENTROPY.textContent =
        `${RES.entropy.toFixed(0)} % ¬∑ Heat ${game.avgHeat.toFixed(0)}%`;

      HUD_PRESTIGE_ZONE.innerHTML = '';
      const canPrestige =
        RES.matter >= 1_000_000 &&
        RES.energy >= 500_000 &&
        RES.entropy >= 90;
      if (canPrestige) {
        const btn = document.createElement('button');
        btn.className = 'prestige-btn';
        btn.textContent = 'Prestige disponible';
        btn.onclick = () => { tryPrestige(); };
        HUD_PRESTIGE_ZONE.appendChild(btn);
      } else {
        HUD_PRESTIGE_ZONE.textContent =
          'Prestige: üß±1M ¬∑ ‚ö°500k ¬∑ üå™90%';
      }
    }

    /* ---------- GAME LOOP ---------- */

    function gameLoop(timestamp) {
      if (!game.running) return;
      if (!game.lastTime) game.lastTime = timestamp;
      let dt = (timestamp - game.lastTime) / 1000;
      if (dt < 1 / 60) dt = 1 / 60;
      if (dt > 1 / 30) dt = 1 / 30;
      game.lastTime = timestamp;

      update(dt);
      render();
      updateUI();

      requestAnimationFrame(gameLoop);
    }

    /* ---------- BOOT ---------- */

    initGrid();
    initParticles();
    resizeCanvas();
    buildTechUI();
    requestAnimationFrame(gameLoop);

    // FUTUR : syst√®me de sauvegarde (localStorage), export/import, et presets de layout
  </script>
</body>
</html>

